$experimental-support-for-opera: true !default;
$experimental-support-for-microsoft: true !default;
$legacy-support-for-mozilla: true !default;

$base-font-size: 16px !default;
$base-line-height: 24px !default;

$rhythm-unit: 'em' !default;

$browser-default-font-size: 16px;

$use-mozilla-ellipsis-binding: true;

@function convert-length(
  $length,
  $to-unit,
  $from-context: $base-font-size,
  $to-context: $from-context
) {

  $from-unit: unit($length);

  // Optimize for cases where `from` and `to` units are accidentally the same.
  @if $from-unit == $to-unit { @return $length; }

  // Context values must be in px so we can determine a conversion ratio for
  // relative units.
  @if unit($from-context) != 'px' { @warn "Paremeter $from-context must resolve to a value in pixel units."; }
  @if unit($to-context) != 'px' { @warn "Parameter $to-context must resolve to a value in pixel units."; }

  // Convert input length to pixels
  $px-length: $length;

  @if $from-unit != 'px' {
    // Convert relative units using the from-context parameter.
    @if      $from-unit == 'em'  { $px-length: $length * $from-context / 1em }
    @else if $from-unit == 'rem' { $px-length: $length * $base-font-size / 1rem }
    @else if $from-unit == '%'   { $px-length: $length * $from-context / 100% }
    @else if $from-unit == 'ex'  { $px-length: $length * $from-context / 2ex }
    // Convert absolute units using Sass' conversion table.
    @else if $from-unit == 'in'  or
             $from-unit == 'mm'  or
             $from-unit == 'cm'  or
             $from-unit == 'pt'  or
             $from-unit == 'pc'  { $px-length: 0px + $length }
    // Certain units can't be converted.
    @else if $from-unit == 'ch'  or
             $from-unit == 'vw'  or
             $from-unit == 'vh'  or
             $from-unit == 'vmin' {
      @warn "#{$from-unit} units can't be reliably converted; Returning original value.";
      @return $length;
    }
    @else {
      @warn "#{$from-unit} is an unknown length unit. Returning original value.";
      @return $length;
    }
  }

  // Convert length in pixels to the output unit
  $output-length: $px-length;
  @if $to-unit != 'px' {
    // Relative units
    @if      $to-unit == 'em'  { $output-length: $px-length * 1em / $to-context }
    @else if $to-unit == 'rem' { $output-length: $px-length * 1rem / $base-font-size }
    @else if $to-unit == '%'   { $output-length: $px-length * 100% / $to-context }
    @else if $to-unit == 'ex'  { $output-length: $px-length * 2ex / $to-context }
    // Absolute units
    @else if $to-unit == 'in'  { $output-length: 0in + $px-length }
    @else if $to-unit == 'mm'  { $output-length: 0mm + $px-length }
    @else if $to-unit == 'cm'  { $output-length: 0cm + $px-length }
    @else if $to-unit == 'pt'  { $output-length: 0pt + $px-length }
    @else if $to-unit == 'pc'  { $output-length: 0pc + $px-length }
    // Non-convertible units
    @else if $to-unit == 'ch'  or
             $to-unit == 'vw'  or
             $to-unit == 'vh'  or
             $to-unit == 'vmin' {
      @warn "#{$to-unit} units can't be reliably converted; Returning original value.";
      @return $length;
    }
    @else {
      @warn "#{$to-unit} is an unknown length unit. Returning original value.";
      @return $length;
    }
  }

  @return $output-length;
}

@function rhythm($lines: 1, $font-size: $base-font-size, $offset: 0) {
  $rhythm: convert-length($lines * $base-line-height - $offset, $rhythm-unit, $font-size);
  @if unit($rhythm) == px {
    $rhythm: floor($rhythm);
  }
  @return $rhythm;
}

@function lines-for-font-size($font-size) {
  $lines: if($round-to-nearest-half-line,
             ceil(2 * $font-size / $base-line-height) / 2,
             ceil($font-size / $base-line-height));
  // If lines are cramped include some extra lead.
  @if ($lines * $base-line-height - $font-size) < ($min-line-padding * 2) {
    $lines: $lines + if($round-to-nearest-half-line, 0.5, 1);
  }
  @return $lines;
}

@mixin experimental($property, $value,
  $moz      : $experimental-support-for-mozilla,
  $webkit   : $experimental-support-for-webkit,
  $o        : $experimental-support-for-opera,
  $ms       : $experimental-support-for-microsoft,
  $khtml    : $experimental-support-for-khtml,
  $official : true
) {
  @if $webkit  and $experimental-support-for-webkit    { -webkit-#{$property} : $value; }
  @if $khtml   and $experimental-support-for-khtml     {  -khtml-#{$property} : $value; }
  @if $moz     and $experimental-support-for-mozilla   {    -moz-#{$property} : $value; }
  @if $ms      and $experimental-support-for-microsoft {     -ms-#{$property} : $value; }
  @if $o       and $experimental-support-for-opera     {      -o-#{$property} : $value; }
  @if $official                                        {         #{$property} : $value; }
}

@mixin output-rhythm($property, $values) {
  @if $rhythm-unit == rem and $rem-with-px-fallback {
    @include rem($property, $values);
  }
  @else {
    $output: ();
    @each $value in $values {
      @if unit($value) == px {
        // Ensure all pixel values are rounded to the nearest pixel.
        $output: join($output, round($value));
      }
      @else {
        $output: join($output, $value);
      }
    }
    #{$property}: $output;
  }
}

@mixin establish-baseline($font-size: $base-font-size) {
  $relative-size: 100% * ($font-size / $browser-default-font-size);

  @if support-legacy-browser(ie, "6") and (not $relative-font-sizing) {
    // IE 6 refuses to resize fonts set in pixels and it weirdly resizes fonts
    // whose root is set in ems. So we set the root font size in percentages of
    // the default font size, even if we are using absolute sizes elsewhere.
    * html { font-size: $relative-size; }
  }
  html {
    font-size: if($relative-font-sizing, $relative-size, $font-size);

    // Webkit has a bug that prevents line-height being set in rem on <html>;
    // To work around this and simplify output, we can set initial line-height
    // in ems for all relative rhythm units, even when $rhythm-unit is `rem`.
    @if $relative-font-sizing {
      line-height: convert-length($base-line-height, em);
    }
    @else {
      line-height: round($base-line-height);
    }
  }
}

@mixin adjust-font-size-to($to-size, $lines: auto, $from-size: $base-font-size) {
  $to-size: convert-length($to-size, px, $from-size);
  @if $lines == auto {
    $lines: lines-for-font-size($to-size);
  }
  @include output-rhythm(font-size, convert-length($to-size, $rhythm-unit, $from-size));
  @include adjust-leading-to($lines, $to-size);
}

@mixin adjust-leading-to($lines, $font-size: $base-font-size) {
  @include output-rhythm(line-height, rhythm($lines, $font-size));
}

@mixin leader($lines: 1, $font-size: $base-font-size, $property: margin) {
  @include output-rhythm(#{$property}-top, rhythm($lines, $font-size));
}

@mixin padding-leader($lines: 1, $font-size: $base-font-size) {
  @include output-rhythm(padding-top, rhythm($lines, $font-size));
}

@mixin trailer($lines: 1, $font-size: $base-font-size, $property: margin) {
  @include output-rhythm(#{$property}-bottom, rhythm($lines, $font-size));
}

@mixin padding-trailer($lines: 1, $font-size: $base-font-size) {
  @include output-rhythm(padding-bottom, rhythm($lines, $font-size));
}

@mixin rhythm(
  $leader: 1,
  $padding-leader: 0,
  $padding-trailer: $padding-leader,
  $trailer: $leader,
  $font-size: $base-font-size
) {
  @include leader($leader, $font-size);
  @include padding-leader($padding-leader, $font-size);
  @include padding-trailer($padding-trailer, $font-size);
  @include trailer($trailer, $font-size);
}

@mixin apply-side-rhythm-border(
  $side,
  $width: $default-rhythm-border-width,
  $lines: 1,
  $font-size: $base-font-size,
  $border-style: $default-rhythm-border-style
) {
  // If applying borders to all sides, use shorthand properties
  $border-prop: if($side == all, border, border-#{$side});
  @include output-rhythm(#{$border-prop}-width, convert-length($width, $rhythm-unit, $font-size));
  #{$border-prop}-style: nth($border-style, 1);
  @if type-of($border-style) == list and length($border-style) > 1 {
    #{$border-prop}-color: nth($border-style, 2);
  }
  $padding-prop: if($side == all, padding, padding-#{$side});
  @include output-rhythm(#{$padding-prop}, rhythm($lines, $font-size, $offset: $width));
}

@mixin rhythm-borders(
  $width: $default-rhythm-border-width,
  $lines: 1,
  $font-size: $base-font-size,
  $border-style: $default-rhythm-border-style
) {
  @include apply-side-rhythm-border(all, $width, $lines, $font-size, $border-style);
}

@mixin ellipsis($no-wrap: true) {
  @if $no-wrap { white-space: nowrap; }
  overflow: hidden;
  @include experimental(text-overflow, ellipsis,
    not -moz,
    not -webkit,
    -o,
    -ms,
    not -khtml,
    official
  );
  @if $legacy-support-for-mozilla and $use-mozilla-ellipsis-binding {
    -moz-binding: stylesheet-url(unquote("xml/ellipsis.xml#ellipsis"));
  }
}

@mixin stretch($offset-top:0, $offset-right:0, $offset-bottom:0, $offset-left:0) {
  position: absolute;
  @if $offset-top { top: $offset-top; }
  @if $offset-bottom { bottom: $offset-bottom; }
  @if $offset-left { left: $offset-left; }
  @if $offset-right { right: $offset-right; }
}

